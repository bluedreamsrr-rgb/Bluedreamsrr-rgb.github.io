<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computer Science â€” TCVP Evidence</title>
    <link rel="stylesheet" href="../style.css">
    <style>
        .instance {
            margin-top: 2em;
            padding: 1em;
            background: #f8f9fa;
            border-left: 4px solid #4a90e2;
        }
        .instance h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        .observer-graph {
            font-family: 'Courier New', monospace;
            background: #fff;
            padding: 0.5em;
            border: 1px solid #ddd;
            margin: 1em 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ’» Computer Science</h1>
        <p><em>Instances of triune structure in software architecture, version control, machine learning, and computing systems.</em></p>

        <hr>

        <div class="instance">
            <h3>Model-View-Controller (MVC)</h3>
            <p><strong>System:</strong> Model, View, Controller, Software application</p>
            <p><strong>Triune Decomposition:</strong></p>
            <ul>
                <li><strong>Source:</strong> Model â€” data, state, business logic</li>
                <li><strong>Witness:</strong> View â€” presentation, UI, output rendering</li>
                <li><strong>Mediator:</strong> Controller â€” input handling, state updates, Model-View synchronization</li>
            </ul>
            <div class="observer-graph">
                Model observes Controller â†’ data mutated via commands â†’ View observes Model â†’ display updates on change â†’ Controller observes View and Model â†’ interprets input, updates both
            </div>
            <p><strong>Î¦(S) = 1</strong></p>
            <p><strong>Diagnostic:</strong> Without Model â†’ stateless view, no persistence. Without View â†’ no user feedback, blind controller. Without Controller â†’ no input routing, model/view drift. Triune separation of concerns is the minimal stable UI architecture.</p>
        </div>

        <div class="instance">
            <h3>Git Version Control</h3>
            <p><strong>System:</strong> Working copy, Commit history, Merge operation, Repository</p>
            <p><strong>Triune Decomposition:</strong></p>
            <ul>
                <li><strong>Source:</strong> Working copy â€” current file state, unstaged changes</li>
                <li><strong>Witness:</strong> Commit history â€” immutable log of past states</li>
                <li><strong>Mediator:</strong> Merge / rebase â€” reconciliation operation between branches</li>
            </ul>
            <div class="observer-graph">
                Working copy observes history â†’ diff, blame, checkout â†’ history observes working copy â†’ commit creates new history node â†’ merge observes both working copy and history â†’ resolves divergent states
            </div>
            <p><strong>Î¦(S) = 1</strong></p>
            <p><strong>Diagnostic:</strong> No working copy â†’ can't edit; system is read-only archive. No history â†’ can't track changes; system is ephemeral scratchpad. No merge â†’ can't reconcile; system forces linear or forked stagnation. Git persists because it closes the edit-commit-merge loop.</p>
        </div>

        <div class="instance">
            <h3>Transformer Architecture</h3>
            <p><strong>System:</strong> Self-attention, Feed-forward network, Residual connection, Layer normalization</p>
            <p><strong>Triune Decomposition:</strong></p>
            <ul>
                <li><strong>Source:</strong> Self-attention â€” computes pairwise token relations; context-aware representations</li>
                <li><strong>Witness:</strong> Feed-forward network â€” processes each token independently; nonlinear transformation</li>
                <li><strong>Mediator:</strong> Residual connection â€” adds input to output; enables gradient flow; preserves information</li>
            </ul>
            <div class="observer-graph">
                Self-attention observes input tokens â†’ weighted sum across sequence â†’ feed-forward network observes self-attention output â†’ per-token computation â†’ residual connection observes both input and output â†’ skip connection preserves identity
            </div>
            <p><strong>Î¦(S) = 1</strong></p>
            <p><strong>Diagnostic:</strong> No attention â†’ no context; tokens processed independently; bag-of-words model. No FFN â†’ no nonlinearity; pure attention is linear; no depth benefit. No residual â†’ gradients vanish in deep models; training collapses. Transformer persists because it closes relation â†’ transformation â†’ preservation.</p>
        </div>

        <div class="instance">
            <h3>Actor-Critic Reinforcement Learning</h3>
            <p><strong>System:</strong> Actor, Critic, Environment, TD error, Policy update</p>
            <p><strong>Triune Decomposition:</strong></p>
            <ul>
                <li><strong>Source:</strong> Actor â€” policy Ï€(a|s); selects actions</li>
                <li><strong>Witness:</strong> Critic â€” value function V(s) or Q(s,a); estimates expected return</li>
                <li><strong>Mediator:</strong> TD error / Advantage â€” Î´ = r + Î³V(s') - V(s); drives policy and value updates</li>
            </ul>
            <div class="observer-graph">
                Actor observes environment state â†’ selects action â†’ critic observes state and reward â†’ estimates value â†’ TD error observes both actor and critic â†’ compares expected vs. actual return â†’ policy gradient observes TD error â†’ updates actor toward higher-value actions
            </div>
            <p><strong>Î¦(S) = 1</strong></p>
            <p><strong>Diagnostic:</strong> No actor â†’ no policy; agent never acts. No critic â†’ no value estimate; policy gradient has no baseline; high variance. No TD error â†’ no learning signal; actor cannot improve. Actor-critic closes action â†’ evaluation â†’ improvement.</p>
        </div>

        <div class="instance">
            <h3>Quantum Error Correction</h3>
            <p><strong>System:</strong> Physical qubits, Encoding operation, Logical qubit, Syndrome measurement</p>
            <p><strong>Triune Decomposition:</strong></p>
            <ul>
                <li><strong>Source:</strong> Physical qubits â€” noisy, error-prone hardware substrate</li>
                <li><strong>Witness:</strong> Encoding operation â€” maps logical state to entangled physical state; redundancy</li>
                <li><strong>Mediator:</strong> Syndrome measurement â€” detects errors without disturbing logical state; correction operator</li>
            </ul>
            <div class="observer-graph">
                Physical qubits observe encoding â†’ become entangled representation of logical state â†’ encoding observes physical qubits â†’ distributes information across degrees of freedom â†’ syndrome measurement observes both physical qubits and encoding â†’ detects discrepancies from code subspace
            </div>
            <p><strong>Î¦(S) = 1</strong> (below threshold)</p>
            <p><strong>Diagnostic:</strong> No physical qubits â†’ no substrate; information has no carrier. No encoding â†’ no redundancy; single error destroys logical state. No syndrome measurement â†’ no error detection; errors accumulate uncorrected. QEC closes noisy substrate â†’ redundancy â†’ active correction.</p>
        </div>

        <div class="instance">
            <h3>Three-Tier Architecture</h3>
            <p><strong>System:</strong> Presentation tier, Logic tier, Data tier, Web application</p>
            <p><strong>Triune Decomposition:</strong></p>
            <ul>
                <li><strong>Source:</strong> Presentation tier â€” UI, user interaction, client-side rendering</li>
                <li><strong>Witness:</strong> Logic tier â€” business rules, application logic, processing</li>
                <li><strong>Mediator:</strong> Data tier â€” database, storage, persistence</li>
            </ul>
            <div class="observer-graph">
                Presentation observes user input â†’ sends requests â†’ logic observes presentation â†’ processes business rules â†’ data observes logic â†’ stores/retrieves information â†’ logic observes data â†’ formats response â†’ presentation observes logic â†’ renders output
            </div>
            <p><strong>Î¦(S) = 1</strong></p>
            <p><strong>Diagnostic:</strong> Two-tier (client-server) â†’ business logic embedded in presentation or data; maintenance nightmare. Three-tier â†’ separation of concerns; scalability; maintainability. The minimal stable enterprise architecture.</p>
        </div>

        <div class="instance">
            <h3>TCP/IP Protocol Stack (Three Layers Simplified)</h3>
            <p><strong>System:</strong> Application layer, Transport layer, Internet layer, Network communication</p>
            <p><strong>Triune Decomposition:</strong></p>
            <ul>
                <li><strong>Source:</strong> Application layer â€” HTTP, FTP, SMTP; user data generation</li>
                <li><strong>Witness:</strong> Transport layer â€” TCP/UDP; segmentation, reliability, flow control</li>
                <li><strong>Mediator:</strong> Internet layer â€” IP; routing, addressing, packet delivery</li>
            </ul>
            <div class="observer-graph">
                Application observes user â†’ generates data â†’ transport observes application â†’ segments, adds ports, ensures reliability â†’ internet observes transport â†’ packets, adds IP addresses, routes â†’ network interface observes internet â†’ frames, sends physically
            </div>
            <p><strong>Î¦(S) = 1</strong></p>
            <p><strong>Diagnostic:</strong> Three layers (simplified) are the minimal complete networking stack. Application generates, transport manages, internet delivers. Each layer observes and serves the others.</p>
        </div>

        <div class="instance">
            <h3>Database ACID Properties (Three Key Ones)</h3>
            <p><strong>System:</strong> Atomicity, Consistency, Durability, Transaction processing</p>
            <p><strong>Triune Decomposition:</strong></p>
            <ul>
                <li><strong>Source:</strong> Atomicity â€” all-or-nothing execution; transaction as unit</li>
                <li><strong>Witness:</strong> Consistency â€” integrity constraints; valid state transitions</li>
                <li><strong>Mediator:</strong> Durability â€” committed changes persist; survives failures</li>
            </ul>
            <div class="observer-graph">
                Atomicity observes transaction â†’ ensures complete execution â†’ consistency observes atomicity â†’ validates state changes â†’ durability observes consistency â†’ persists committed results
            </div>
            <p><strong>Î¦(S) = 1</strong></p>
            <p><strong>Diagnostic:</strong> Atomicity alone â†’ all-or-nothing, but could violate rules or disappear. Consistency alone â†’ valid states, but partial updates possible. Durability alone â†’ persistence, but inconsistent or partial states could be saved. Three together close transaction processing.</p>
        </div>

        <div class="instance">
            <h3>MapReduce Programming Model</h3>
            <p><strong>System:</strong> Map phase, Shuffle phase, Reduce phase, Distributed computation</p>
            <p><strong>Triune Decomposition:</strong></p>
            <ul>
                <li><strong>Source:</strong> Map phase â€” processes input; emits intermediate key-value pairs</li>
                <li><strong>Witness:</strong> Shuffle phase â€” sorts, groups, and transfers data between nodes</li>
                <li><strong>Mediator:</strong> Reduce phase â€” aggregates intermediate results; produces final output</li>
            </ul>
            <div class="observer-graph">
                Map observes input data â†’ emits key-value pairs â†’ shuffle observes map output â†’ groups by key; redistributes â†’ reduce observes shuffled data â†’ aggregates per key; produces final result
            </div>
            <p><strong>Î¦(S) = 1</strong></p>
            <p><strong>Diagnostic:</strong> Map alone â†’ parallel processing, but no aggregation. Shuffle alone â†’ data movement, but no processing. Reduce alone â†’ aggregation, but no parallel input. Three phases together enable distributed data processing at scale.</p>
        </div>

        <div class="instance">
            <h3>Three-Valued Logic (SQL NULL)</h3>
            <p><strong>System:</strong> TRUE, FALSE, UNKNOWN (NULL), Three-valued logic</p>
            <p><strong>Triune Decomposition:</strong></p>
            <ul>
                <li><strong>Source:</strong> TRUE â€” satisfied condition; positive truth</li>
                <li><strong>Witness:</strong> FALSE â€” unsatisfied condition; negative truth</li>
                <li><strong>Mediator:</strong> UNKNOWN (NULL) â€” missing information; neither true nor false</li>
            </ul>
            <div class="observer-graph">
                TRUE observes comparison â†’ satisfied â†’ FALSE observes comparison â†’ unsatisfied â†’ UNKNOWN observes missing data â†’ neither satisfied nor unsatisfied â†’ logical operations observe all three â†’ AND/OR/NOT defined for three values
            </div>
            <p><strong>Î¦(S) = 1</strong></p>
            <p><strong>Diagnostic:</strong> Two-valued logic cannot represent missing information. Three-valued logic with NULL is the minimal complete logic for databases with incomplete data. All SQL implementations use it.</p>
        </div>

        <hr>

        <div class="footer">
            <a href="catalog.html">â† Back to evidence catalog</a> &nbsp;|&nbsp;
            <a href="../index.html">Home</a>
        </div>
    </div>
</body>
                      </html>
